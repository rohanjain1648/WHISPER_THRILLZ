import { User, Message, Relationship, Playlist } from '../models';

describe('Database Models', () => {

  describe('User Model', () => {
    it('should have correct schema structure', () => {
      const userData = {
        email: 'test@example.com',
        hashedPassword: 'hashedpassword123',
        profile: {
          displayName: 'Test User',
          interests: ['music', 'art']
        },
        moodHistory: [{
          emotions: {
            joy: 0.8,
            sadness: 0.1,
            anger: 0.0,
            fear: 0.1,
            surprise: 0.2,
            disgust: 0.0,
            trust: 0.7,
            anticipation: 0.6
          },
          sentiment: 0.7,
          intensity: 0.8,
          timestamp: new Date()
        }]
      };

      const user = new User(userData);
      
      expect(user.email).toBe(userData.email);
      expect(user.profile.displayName).toBe('Test User');
      expect(user.moodHistory).toHaveLength(1);
      expect(user.moodHistory[0].emotions.joy).toBe(0.8);
    });

    it('should have required validation rules', () => {
      const user = new User({});
      const validationError = user.validateSync();
      
      expect(validationError).toBeDefined();
      expect(validationError?.errors.email).toBeDefined();
      expect(validationError?.errors.hashedPassword).toBeDefined();
    });
  });

  describe('Message Model', () => {
    it('should have correct schema structure', () => {
      const messageData = {
        content: 'A beautiful whisper in the wind',
        location: {
          type: 'Point' as const,
          coordinates: [-74.0060, 40.7128] // NYC coordinates [lng, lat]
        },
        moodEmbedding: {
          emotions: {
            joy: 0.9,
            sadness: 0.0,
            anger: 0.0,
            fear: 0.0,
            surprise: 0.3,
            disgust: 0.0,
            trust: 0.8,
            anticipation: 0.7
          },
          sentiment: 0.8,
          intensity: 0.9,
          timestamp: new Date()
        },
        isAnonymous: true,
        moderationStatus: 'approved' as const
      };

      const message = new Message(messageData);

      expect(message.content).toBe(messageData.content);
      expect(message.location.coordinates).toEqual([-74.0060, 40.7128]);
      expect(message.moodEmbedding.emotions.joy).toBe(0.9);
      expect(message.isAnonymous).toBe(true);
    });

    it('should validate required fields', () => {
      const message = new Message({});
      const validationError = message.validateSync();
      
      expect(validationError).toBeDefined();
      expect(validationError?.errors.content).toBeDefined();
      expect(validationError?.errors.moodEmbedding).toBeDefined();
    });
  });

  describe('Relationship Model', () => {
    it('should have correct schema structure', () => {
      const relationshipData = {
        users: ['507f1f77bcf86cd799439011', '507f1f77bcf86cd799439012'],
        type: 'couple' as const,
        initiatedBy: '507f1f77bcf86cd799439011',
        status: 'active' as const
      };

      const relationship = new Relationship(relationshipData);

      expect(relationship.users).toHaveLength(2);
      expect(relationship.type).toBe('couple');
      expect(relationship.bondingMetrics.closeness).toBe(50); // default value
      expect(relationship.status).toBe('active');
    });

    it('should validate required fields', () => {
      const relationship = new Relationship({});
      const validationError = relationship.validateSync();
      
      expect(validationError).toBeDefined();
      // Check that validation errors exist for required fields
      expect(Object.keys(validationError?.errors || {})).toContain('type');
      expect(Object.keys(validationError?.errors || {})).toContain('initiatedBy');
    });
  });

  describe('Playlist Model', () => {
    it('should have correct schema structure', () => {
      const playlistData = {
        name: 'My Mood Playlist',
        description: 'A playlist for my current mood',
        moodContext: {
          emotions: {
            joy: 0.8, sadness: 0.1, anger: 0.0, fear: 0.1,
            surprise: 0.2, disgust: 0.0, trust: 0.7, anticipation: 0.6
          },
          sentiment: 0.7,
          intensity: 0.8,
          timestamp: new Date()
        },
        createdBy: '507f1f77bcf86cd799439011',
        tracks: [{
          spotifyId: 'track123',
          name: 'Happy Song',
          artist: 'Joy Artist',
          moodScore: 0.8,
          addedAt: new Date()
        }],
        isAutoGenerated: true
      };

      const playlist = new Playlist(playlistData);

      expect(playlist.name).toBe(playlistData.name);
      expect(playlist.tracks).toHaveLength(1);
      expect(playlist.tracks[0].spotifyId).toBe('track123');
      expect(playlist.moodContext.emotions.joy).toBe(0.8);
      expect(playlist.isAutoGenerated).toBe(true);
    });

    it('should validate required fields', () => {
      const playlist = new Playlist({});
      const validationError = playlist.validateSync();
      
      expect(validationError).toBeDefined();
      expect(validationError?.errors.name).toBeDefined();
      expect(validationError?.errors.moodContext).toBeDefined();
      expect(validationError?.errors.createdBy).toBeDefined();
    });
  });

  describe('Model Schema Validation', () => {
    it('should have proper schema paths defined', () => {
      // Test that models have the expected schema paths
      expect(User.schema.paths.email).toBeDefined();
      expect(User.schema.paths.moodHistory).toBeDefined();
      expect(User.schema.paths.profile).toBeDefined();

      expect(Message.schema.paths.content).toBeDefined();
      expect(Message.schema.paths.isAnonymous).toBeDefined();
      expect(Message.schema.paths.moderationStatus).toBeDefined();

      expect(Relationship.schema.paths.users).toBeDefined();
      expect(Relationship.schema.paths.type).toBeDefined();
      expect(Relationship.schema.paths.status).toBeDefined();

      expect(Playlist.schema.paths.name).toBeDefined();
      expect(Playlist.schema.paths.createdBy).toBeDefined();
      expect(Playlist.schema.paths.isShared).toBeDefined();
    });

    it('should have proper enum validations', () => {
      // Test enum validations for relationship type
      const relationshipTypeEnum = Relationship.schema.paths.type as any;
      expect(relationshipTypeEnum.enumValues).toContain('couple');
      expect(relationshipTypeEnum.enumValues).toContain('friends');
      expect(relationshipTypeEnum.enumValues).toContain('family');

      // Test enum validations for message moderation status
      const messageStatusEnum = Message.schema.paths.moderationStatus as any;
      expect(messageStatusEnum.enumValues).toContain('pending');
      expect(messageStatusEnum.enumValues).toContain('approved');
      expect(messageStatusEnum.enumValues).toContain('rejected');
    });
  });
});