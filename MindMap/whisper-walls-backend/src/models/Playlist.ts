import mongoose, { Document, Schema } from 'mongoose';
import { MoodEmbedding } from './User';

export interface PlaylistTrack {
  spotifyId: string;
  name: string;
  artist: string;
  album?: string;
  duration?: number;
  previewUrl?: string;
  moodScore: number;
  addedAt: Date;
  addedBy?: mongoose.Types.ObjectId;
}

export interface SpotifyIntegration {
  playlistId?: string;
  playlistUrl?: string;
  isPublic: boolean;
  lastSyncedAt?: Date;
  syncStatus: 'pending' | 'synced' | 'failed' | 'not_synced';
}

export interface PlaylistMetadata {
  genre: string[];
  energy: number; // 0-1
  valence: number; // 0-1 (musical positivity)
  danceability: number; // 0-1
  acousticness: number; // 0-1
  instrumentalness: number; // 0-1
}

export interface IPlaylist extends Document {
  name: string;
  description: string;
  moodContext: MoodEmbedding;
  tracks: PlaylistTrack[];
  isShared: boolean;
  collaborators: mongoose.Types.ObjectId[];
  createdBy: mongoose.Types.ObjectId;
  relationshipId?: mongoose.Types.ObjectId;
  spotifyIntegration: SpotifyIntegration;
  metadata: PlaylistMetadata;
  tags: string[];
  isAutoGenerated: boolean;
  generationPrompt?: string;
  playCount: number;
  lastPlayedAt?: Date;
  createdAt: Date;
  updatedAt: Date;
  
  // Instance methods
  addTrack(track: Omit<PlaylistTrack, 'addedAt'>, addedBy?: mongoose.Types.ObjectId): Promise<IPlaylist>;
  removeTrack(spotifyId: string): Promise<IPlaylist>;
  incrementPlayCount(): Promise<IPlaylist>;
  updateSpotifySync(playlistId: string, playlistUrl: string, status?: 'pending' | 'synced' | 'failed'): Promise<IPlaylist>;
  addCollaborator(userId: mongoose.Types.ObjectId): Promise<IPlaylist>;
  removeCollaborator(userId: mongoose.Types.ObjectId): Promise<IPlaylist>;
}

// Playlist Track Schema
const PlaylistTrackSchema = new Schema<PlaylistTrack>({
  spotifyId: {
    type: String,
    required: true,
    trim: true
  },
  name: {
    type: String,
    required: true,
    trim: true,
    maxlength: 200
  },
  artist: {
    type: String,
    required: true,
    trim: true,
    maxlength: 200
  },
  album: {
    type: String,
    trim: true,
    maxlength: 200
  },
  duration: {
    type: Number,
    min: 0
  },
  previewUrl: {
    type: String,
    trim: true
  },
  moodScore: {
    type: Number,
    required: true,
    min: 0,
    max: 1
  },
  addedAt: {
    type: Date,
    default: Date.now
  },
  addedBy: {
    type: Schema.Types.ObjectId,
    ref: 'User'
  }
}, { _id: false });

// Spotify Integration Schema
const SpotifyIntegrationSchema = new Schema<SpotifyIntegration>({
  playlistId: {
    type: String,
    trim: true
  },
  playlistUrl: {
    type: String,
    trim: true
  },
  isPublic: {
    type: Boolean,
    default: false
  },
  lastSyncedAt: {
    type: Date
  },
  syncStatus: {
    type: String,
    enum: ['pending', 'synced', 'failed', 'not_synced'],
    default: 'not_synced'
  }
}, { _id: false });

// Playlist Metadata Schema
const PlaylistMetadataSchema = new Schema<PlaylistMetadata>({
  genre: [{
    type: String,
    trim: true,
    maxlength: 50
  }],
  energy: {
    type: Number,
    min: 0,
    max: 1,
    default: 0.5
  },
  valence: {
    type: Number,
    min: 0,
    max: 1,
    default: 0.5
  },
  danceability: {
    type: Number,
    min: 0,
    max: 1,
    default: 0.5
  },
  acousticness: {
    type: Number,
    min: 0,
    max: 1,
    default: 0.5
  },
  instrumentalness: {
    type: Number,
    min: 0,
    max: 1,
    default: 0.5
  }
}, { _id: false });

// Mood Embedding Schema (reused from User model)
const MoodEmbeddingSchema = new Schema<MoodEmbedding>({
  emotions: {
    joy: { type: Number, required: true, min: 0, max: 1 },
    sadness: { type: Number, required: true, min: 0, max: 1 },
    anger: { type: Number, required: true, min: 0, max: 1 },
    fear: { type: Number, required: true, min: 0, max: 1 },
    surprise: { type: Number, required: true, min: 0, max: 1 },
    disgust: { type: Number, required: true, min: 0, max: 1 },
    trust: { type: Number, required: true, min: 0, max: 1 },
    anticipation: { type: Number, required: true, min: 0, max: 1 }
  },
  sentiment: { type: Number, required: true, min: -1, max: 1 },
  intensity: { type: Number, required: true, min: 0, max: 1 },
  timestamp: { type: Date, default: Date.now }
}, { _id: false });

// Main Playlist Schema
const PlaylistSchema = new Schema<IPlaylist>({
  name: {
    type: String,
    required: [true, 'Playlist name is required'],
    trim: true,
    minlength: 1,
    maxlength: 100
  },
  description: {
    type: String,
    trim: true,
    maxlength: 500,
    default: ''
  },
  moodContext: {
    type: MoodEmbeddingSchema,
    required: true
  },
  tracks: [PlaylistTrackSchema],
  isShared: {
    type: Boolean,
    default: false
  },
  collaborators: [{
    type: Schema.Types.ObjectId,
    ref: 'User'
  }],
  createdBy: {
    type: Schema.Types.ObjectId,
    ref: 'User',
    required: true
  },
  relationshipId: {
    type: Schema.Types.ObjectId,
    ref: 'Relationship'
  },
  spotifyIntegration: {
    type: SpotifyIntegrationSchema,
    default: () => ({})
  },
  metadata: {
    type: PlaylistMetadataSchema,
    default: () => ({})
  },
  tags: [{
    type: String,
    trim: true,
    maxlength: 30
  }],
  isAutoGenerated: {
    type: Boolean,
    default: false
  },
  generationPrompt: {
    type: String,
    trim: true,
    maxlength: 500
  },
  playCount: {
    type: Number,
    default: 0,
    min: 0
  },
  lastPlayedAt: {
    type: Date
  }
}, {
  timestamps: true,
  toJSON: {
    transform: function(doc, ret) {
      delete (ret as any).__v;
      return ret;
    }
  }
});

// Indexes for performance
PlaylistSchema.index({ createdBy: 1, createdAt: -1 });
PlaylistSchema.index({ collaborators: 1 });
PlaylistSchema.index({ relationshipId: 1 });
PlaylistSchema.index({ isShared: 1, createdAt: -1 });
PlaylistSchema.index({ tags: 1 });
PlaylistSchema.index({ 'moodContext.sentiment': 1 });
PlaylistSchema.index({ 'moodContext.emotions.joy': 1 });
PlaylistSchema.index({ 'metadata.genre': 1 });
PlaylistSchema.index({ 'metadata.energy': 1 });
PlaylistSchema.index({ 'metadata.valence': 1 });
PlaylistSchema.index({ 'spotifyIntegration.playlistId': 1 });
PlaylistSchema.index({ playCount: -1 });
PlaylistSchema.index({ lastPlayedAt: -1 });

// Compound indexes for complex queries
PlaylistSchema.index({ createdBy: 1, isShared: 1, createdAt: -1 });
PlaylistSchema.index({ relationshipId: 1, createdAt: -1 });

// Static method to find playlists for user
PlaylistSchema.statics.findForUser = function(
  userId: mongoose.Types.ObjectId,
  options: {
    includeShared?: boolean;
    includeCollaborative?: boolean;
    limit?: number;
    sortBy?: 'createdAt' | 'playCount' | 'lastPlayedAt';
  } = {}
) {
  const query: any = {
    $or: [
      { createdBy: userId }
    ]
  };

  if (options.includeShared) {
    query.$or.push({ isShared: true });
  }

  if (options.includeCollaborative) {
    query.$or.push({ collaborators: userId });
  }

  let sort: any = { createdAt: -1 };
  if (options.sortBy === 'playCount') {
    sort = { playCount: -1, createdAt: -1 };
  } else if (options.sortBy === 'lastPlayedAt') {
    sort = { lastPlayedAt: -1, createdAt: -1 };
  }

  return this.find(query)
    .populate('createdBy', 'profile.displayName')
    .populate('collaborators', 'profile.displayName')
    .populate('relationshipId', 'type users')
    .sort(sort)
    .limit(options.limit || 50);
};

// Static method to find playlists by mood similarity
PlaylistSchema.statics.findByMoodSimilarity = function(
  targetMood: MoodEmbedding,
  options: {
    threshold?: number;
    limit?: number;
    excludeUserId?: mongoose.Types.ObjectId;
  } = {}
) {
  // This would typically use vector similarity search
  // For now, we'll use a simple sentiment-based approach
  const sentimentRange = options.threshold || 0.3;
  
  const query: any = {
    'moodContext.sentiment': {
      $gte: targetMood.sentiment - sentimentRange,
      $lte: targetMood.sentiment + sentimentRange
    }
  };

  if (options.excludeUserId) {
    query.createdBy = { $ne: options.excludeUserId };
  }

  return this.find(query)
    .populate('createdBy', 'profile.displayName')
    .sort({ playCount: -1, createdAt: -1 })
    .limit(options.limit || 20);
};

// Instance method to add track
PlaylistSchema.methods.addTrack = function(
  track: Omit<PlaylistTrack, 'addedAt'>,
  addedBy?: mongoose.Types.ObjectId
) {
  const newTrack: PlaylistTrack = {
    ...track,
    addedAt: new Date(),
    addedBy
  };
  
  // Check if track already exists
  const existingTrack = this.tracks.find(
    (t: PlaylistTrack) => t.spotifyId === track.spotifyId
  );
  
  if (!existingTrack) {
    this.tracks.push(newTrack);
    return this.save();
  }
  
  return Promise.resolve(this);
};

// Instance method to remove track
PlaylistSchema.methods.removeTrack = function(spotifyId: string) {
  this.tracks = this.tracks.filter(
    (track: PlaylistTrack) => track.spotifyId !== spotifyId
  );
  return this.save();
};

// Instance method to increment play count
PlaylistSchema.methods.incrementPlayCount = function() {
  this.playCount += 1;
  this.lastPlayedAt = new Date();
  return this.save();
};

// Instance method to update Spotify sync status
PlaylistSchema.methods.updateSpotifySync = function(
  playlistId: string,
  playlistUrl: string,
  status: 'pending' | 'synced' | 'failed' = 'synced'
) {
  this.spotifyIntegration.playlistId = playlistId;
  this.spotifyIntegration.playlistUrl = playlistUrl;
  this.spotifyIntegration.syncStatus = status;
  this.spotifyIntegration.lastSyncedAt = new Date();
  return this.save();
};

// Instance method to add collaborator
PlaylistSchema.methods.addCollaborator = function(userId: mongoose.Types.ObjectId) {
  if (!this.collaborators.includes(userId)) {
    this.collaborators.push(userId);
    return this.save();
  }
  return Promise.resolve(this);
};

// Instance method to remove collaborator
PlaylistSchema.methods.removeCollaborator = function(userId: mongoose.Types.ObjectId) {
  this.collaborators = this.collaborators.filter(
    (collaborator: mongoose.Types.ObjectId) => !collaborator.equals(userId)
  );
  return this.save();
};

export const Playlist = mongoose.model<IPlaylist>('Playlist', PlaylistSchema);
export default Playlist;